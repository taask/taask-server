# Taask Core Security

Security is the top priority of Taask Core. It is built into the foundation, and every feature and design decision revolves around it. We believe that every layer of the software stack should be secure by default, and the Taask Core maintainers are committed to ensuring the security of the entire system.

- :white_check_mark: Task and result data is opaque and encrypted in transit and at rest.
- :white_check_mark: After task completion, the server loses its ability to decrypt the task or result data
- :white_check_mark: Task and result data is never decrypted until it reaches the runner, only task keys are re-encrypted for runner access to task data

## Taask authentication and encryption
### A high-level overview

__Please note that while this is the spec, it is not yet entirely implemented. Unimplemented portions are denoted with an asterix__

### Groups
- Every client authenticates with a group. When a client submits a task, it belongs to the group it is authenticated with.
	- At startup there exists an admin group, whose keys are generated by the admin deploying Taask Core.
	- The admin group can create and delete additional groups, the admin group cannot be deleted. *

### Auth (server)
- Each group has a _join code_ and a _passphrase_. The passphrase is never known by taask-server.
	- The join code is generated by the server, and the passphrase is generated or chosen by the user.
	- The groups passphrase is put through PBKDF2 to derive the _group key_.
	- The group key is used to encrypt the _task key_, described below.
	- The group join code and the group passphrase are combined and then hashed to create the group _auth hash_. This is known to the server.

### Auth (client)
- Client libraries at startup, generate a _client keypair_, used to authenticate with taask-server.
	- To authenticate, the client combines the group _auth hash_ with a nonce (the current unix timestamp), and signs it with its _client keypair_.
	- This signature, along with the public portion of the signing key and some metadata, constitutes an _auth attempt_. 
	- The attempt is sent to the server, where the signature is verified with the public key against the _auth hash_ stored on the server.
	- The public half is stored on the server to verify later requests.
	- If the attempt is successful, a session challenge is generated (and stored) by the server, encrypted with the public key, and sent back to the client.
	- Clients include a signature (from the same keypair) of the session challenge with future requests to prove it has a valid session.

### Task encryption (client)
- When submitting a task, clients encrypt task data with a unique symmetric _task key_, and then encrypts the _task key_ with the _group key_.
	- The _group key_ encrypted _task key_ is included in the task metadata such that a different client authenticated with the same group can decrypt the result.
- The _task key_ is also encrypted with the _master runner public key_. This encrypted key is also included in the task metadata.
	- The _master runner public key_ is generated by the server at startup, and the private portion is only ever held in memory.
	- The server is able to decrypt the _task key_. This is important, but you will see that the concequences of this are mitigated by the handling of task results.

### Task encryption (runner)
- Every runner generates a _runner keypair_ at startup, used to authenticate with taask-server and decrypt task data.
	- The authentication scheme for runners is identical to clients, except that runner connections are persistent and therefore each session is invalidated after the stream is terminated.
- When a task is assigned to a runner, taask-server re-encrypts the _task key_ using the runner's _runner public key_
	- The runner decrypts the _task key_ and then uses it to decrypt the task data.
- The task key is then used to encrypt the task result data, and the result is returned to the client.
	- Before the result is sent back to the server, the _master runner_ encrypted copy of the task key is deleted, ensuring that the server can no longer decrypt the task data, and can never decrypt the result data. *