// this file contains extensions to the Task struct generated by protoc, do not edit the associated .pb.go file.

package model

import (
	"fmt"

	simplcrypto "github.com/cohix/simplcrypto"
	log "github.com/cohix/simplog"
	"github.com/pkg/errors"
)

// TaskStatusWaiting and others represent the status of a task
const (
	// the task has been recieved, but the client does not want it to be scheduled yet.
	TaskStatusPending = "pending"

	// task is waiting when it has been received but not yet scheduled to a runner
	// waiting tasks will be queued at the first available opportunity
	TaskStatusWaiting = "waiting"

	// task goes waiting -> queued when it has been scheduled to a runner
	TaskStatusQueued = "queued"

	// task goes queued -> running when the runner has begun executing it
	TaskStatusRunning = "running"

	// task goes running -> complete if the runner completes the task with no critical errors.
	// complete does not indicate wether the result of the job contained an error or not, but rather that the runner was able to finish running the task
	TaskStatusCompleted = "complete"

	// task goes running -> failed if the runner cannot complete the job for whatever reason (crash, etc.)
	TaskStatusFailed = "failed"

	// task goes queued -> retrying if the runner a task was scheduled to fails to run the task
	// task goes running -> retrying if the task (runs past the deadline OR runner dies) AND is marked as retryable
	// retrying is similar to waiting, except there will be a backoff before it is re-queued
	TaskStatusRetrying = "retrying"

	// when a task has been unassigned from a runner (i.e. dead task), this value indicates to the updater that the runner UUID should be removed
	RunnerUUIDNone = "NORUNNERUUID"
)

// BuildUpdate applies an update to a task object and returns the update with the updated version number
func (t *Task) BuildUpdate(c TaskChanges) *TaskUpdate {
	update := &TaskUpdate{
		UUID:    t.UUID,
		Version: t.Meta.Version + 1,
		Changes: &c,
	}

	return update
}

// CheckUpdate checks a task update to see if it's allowed
func (t *Task) CheckUpdate(update *TaskUpdate) error {
	if update.Version == t.Meta.Version+1 {
		// cool
	} else {
		return fmt.Errorf("tried to apply update with version %d, task %s has version %d", update.Version, t.UUID, t.Meta.Version)
	}

	if update.Changes.Status != "" && t.Status != update.Changes.Status {
		if t.CanTransitionToState(update.Changes.Status) {
			// cool
		} else {
			return fmt.Errorf("task %s tried to transition from %s to %s, throwing update away", t.UUID, t.Status, update.Changes.Status)
		}
	}

	return nil
}

// ApplyUpdateToTask applies an update to a task and returns the updated task
func ApplyUpdateToTask(task *Task, update *TaskUpdate) (*Task, error) {
	// make a copy
	t := *task

	if update.Version == t.Meta.Version+1 {
		t.Meta.Version = update.Version
	} else {
		return nil, fmt.Errorf("tried to apply update with version %d, task %s has version %d", update.Version, t.UUID, t.Meta.Version)
	}

	if update.Changes.Status != "" && t.Status != update.Changes.Status {
		if t.CanTransitionToState(update.Changes.Status) {
			log.LogInfo(fmt.Sprintf("task %s status updated (%s -> %s)", t.UUID, t.Status, update.Changes.Status))
			t.Status = update.Changes.Status
		} else {
			return nil, fmt.Errorf("task %s tried to transition from %s to %s, throwing update away", t.UUID, t.Status, update.Changes.Status)
		}
	}

	if update.Changes.EncResult != nil {
		t.EncResult = update.Changes.EncResult
	}

	if update.Changes.RunnerUUID != "" && t.Meta.RunnerUUID != update.Changes.RunnerUUID {
		if update.Changes.RunnerUUID == RunnerUUIDNone {
			if t.Meta.RunnerUUID != "" {
				log.LogInfo(fmt.Sprintf("task %s unassigned from runner %s", t.UUID, t.Meta.RunnerUUID))
				t.Meta.RunnerUUID = ""
			}
		} else {
			log.LogInfo(fmt.Sprintf("task %s assigned to runner %s", t.UUID, update.Changes.RunnerUUID))
			t.Meta.RunnerUUID = update.Changes.RunnerUUID
		}
	}

	if len(update.Changes.AddedEncTaskKeys) > 0 {
		for i := range update.Changes.AddedEncTaskKeys {
			log.LogInfo(fmt.Sprintf("task %s added task key encrypted with KID %s", t.UUID, update.Changes.AddedEncTaskKeys[i].KID))

			t.AddEncTaskKey(update.Changes.AddedEncTaskKeys[i])
		}
	}

	if update.Changes.RetrySeconds != 0 && t.Meta.RetrySeconds != update.Changes.RetrySeconds {
		log.LogInfo(fmt.Sprintf("task %s set to retry in %d seconds", t.UUID, update.Changes.RetrySeconds))
		t.Meta.RetrySeconds = update.Changes.RetrySeconds
	}

	if update.Changes.PartnerUUID != "" && t.Meta.PartnerUUID != update.Changes.PartnerUUID {
		log.LogInfo(fmt.Sprintf("task %s assigned to partner %s", t.UUID, update.Changes.PartnerUUID))
		t.Meta.PartnerUUID = update.Changes.PartnerUUID
	}

	return &t, nil
}

// AddEncTaskKey adds an encrypted task key to the task meta
func (t *Task) AddEncTaskKey(encKey *simplcrypto.Message) {
	t.Meta.EncTaskKeys[encKey.KID] = encKey
}

// GetEncTaskKey returns an encrypted task key
func (t *Task) GetEncTaskKey(kid string) *simplcrypto.Message {
	encKey, exists := t.Meta.EncTaskKeys[kid]
	if !exists {
		return nil
	}

	return encKey
}

// DecryptTaskKey decrypts the task key with the provided task key
func (t *Task) DecryptTaskKey(key *simplcrypto.KeyPair) (*simplcrypto.SymKey, error) {
	encKey, exists := t.Meta.EncTaskKeys[key.KID]
	if !exists {
		return nil, fmt.Errorf("no task key encrypted with KID %s found for task %s", key.KID, t.UUID)
	}

	decKeyJSON, err := key.Decrypt(encKey)
	if err != nil {
		return nil, errors.Wrap(err, "failed to decrypt task key")
	}

	taskKey, err := simplcrypto.SymKeyFromJSON(decKeyJSON)
	if err != nil {
		return nil, errors.Wrap(err, "failed to SymKeyFromJSON")
	}

	return taskKey, nil
}

// IsPending is if a task is in pending state
func (t *Task) IsPending() bool {
	return t.Status == TaskStatusPending
}

// IsNotStarted is if a task hasn't even tried to run yet (hasn't been assigned a runner)
func (t *Task) IsNotStarted() bool {
	return t.Status == TaskStatusWaiting || t.Status == TaskStatusRetrying
}

// IsRetrying is if a task hasn't even tried to run yet (hasn't been assigned a runner)
func (t *Task) IsRetrying() bool {
	return t.Status == TaskStatusRetrying
}

// IsRunning is if the task is in the process of being run (has been assigned a runner)
func (t *Task) IsRunning() bool {
	return t.Status == TaskStatusQueued || t.Status == TaskStatusRunning
}

// IsFinished is if the task has run and has a result of some sort
func (t *Task) IsFinished() bool {
	return t.Status == TaskStatusCompleted || t.Status == TaskStatusFailed
}

// CanTransitionToState returns true if a task can go from its current state to new
func (t *Task) CanTransitionToState(new string) bool {
	if t.Status == "" {
		return new == TaskStatusWaiting
	}

	if t.Status == TaskStatusPending {
		return new == TaskStatusWaiting
	}

	if t.Status == TaskStatusWaiting {
		return new == TaskStatusQueued || new == TaskStatusRetrying
	}

	if t.Status == TaskStatusQueued {
		return new == TaskStatusRunning || new == TaskStatusFailed || new == TaskStatusRetrying
	}

	if t.Status == TaskStatusRunning {
		return new == TaskStatusCompleted || new == TaskStatusFailed || new == TaskStatusRetrying
	}

	if t.Status == TaskStatusFailed {
		return new == TaskStatusRetrying
	}

	if t.Status == TaskStatusRetrying {
		return new == TaskStatusQueued
	}

	if t.Status == TaskStatusCompleted {
		return false // just want to be real clear that this should never happen
	}

	return false
}
